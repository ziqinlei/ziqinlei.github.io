{"meta":{"title":"Ziqin Lei's Home","subtitle":null,"description":null,"author":"Ziqin Lei","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-05-13T14:09:37.000Z","updated":"2018-05-13T14:26:05.895Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-13T14:09:18.000Z","updated":"2018-05-13T14:26:17.443Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 访问修饰符","slug":"Java-Access-Modifiers","date":"2018-06-03T07:27:44.000Z","updated":"2018-06-03T07:34:59.742Z","comments":true,"path":"2018/06/03/Java-Access-Modifiers/","link":"","permalink":"http://yoursite.com/2018/06/03/Java-Access-Modifiers/","excerpt":"Java 中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。","text":"Java 中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 public : 对所有类可见。使用对象：类、接口、变量、方法。 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类） default（即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） 对比 访问修饰符 当前类 同包 子类 其他类 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × protected 详解简介实质上，protected 方法的调用是否合法 （编译是否通过）关键是要看被调用的 protected 方法从根源上看所在的类对应的包与调用代码所在的类对应的包是否相同。若相同，则合法；否则，不合法。当然，无论如何，子类是可以访问继承而来的属于它自己的受保护方法的。 举例这种方法的一个最好的实例就是 Object 类中的 clone 方法。protected Object clone() throws CloneNotSupportedException 1234567891011121314package com.ziqin.demo;/** * @author Leiziqin * @since 2018/1/13 */public class TestProtected &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Object o = new Object(); o.clone(); //1 Compilation Error clone()可以在java.lang.Object中访问protected TestProtected testProtected = new TestProtected(); testProtected.clone(); //2 Compilation OK &#125;&#125; 分析1 Compilation Error原因在于：Object 类与 TestProtected 类所在的包不同。Object 类的 protected 方法对于不同包的类不可见。2 Compilation OK原因在于：TestProtected 类继承了 Object 类，所以它的方法可以访问继承自父类的 protected 方法。","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://yoursite.com/categories/Java-基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Streams API In Java 8","slug":"Streams-API-In-Java-8","date":"2018-06-03T06:22:09.000Z","updated":"2018-06-03T06:35:15.310Z","comments":true,"path":"2018/06/03/Streams-API-In-Java-8/","link":"","permalink":"http://yoursite.com/2018/06/03/Streams-API-In-Java-8/","excerpt":"记录项目中 Stream 的具体应用。","text":"记录项目中 Stream 的具体应用。 List 取交集两个存放User的List根据uid是否相同来取交集1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * @author ziqin.lei * @since 2018/5/14 */public class Solution &#123; static class User &#123; private String uid; private String username; User(String uid, String username) &#123; this.uid = uid; this.username = username; &#125; public String getUid() &#123; return uid; &#125; public String getUsername() &#123; return username; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"uid='\" + uid + '\\'' + \", username='\" + username + '\\'' + '&#125;'; &#125; &#125; public static void main(String[] args) &#123; List&lt;User&gt; userList1 = new ArrayList&lt;&gt;(); userList1.add(new User(\"123\", \"小三\")); userList1.add(new User(\"124\", \"小四\")); userList1.add(new User(\"125\", \"小五\")); userList1.add(new User(\"126\", \"小六\")); List&lt;User&gt; userList2 = new ArrayList&lt;&gt;(); userList2.add(new User(\"125\", \"小五\")); userList2.add(new User(\"126\", \"小六\")); userList2.add(new User(\"127\", \"小七\")); userList2.add(new User(\"128\", \"小八\")); List&lt;User&gt; userList = doubleForLoop(userList1, userList2); userList.forEach(System.out::println); userList = toSetAndFilter(userList1, userList2); userList.forEach(System.out::println); &#125; /** * 嵌套for循环 * * @param userList1 列表1 * @param userList2 列表2 * @return 两个列表交集 */ private static List&lt;User&gt; doubleForLoop(List&lt;User&gt; userList1, List&lt;User&gt; userList2) &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); for (User user1 : userList1) &#123; for (User user2 : userList2) &#123; if (Objects.equals(user1.getUid(), user2.getUid())) &#123; userList.add(user1); &#125; &#125; &#125; return userList; &#125; /** * 遍历userList1，创建uidSet，然后遍历userList2过滤 * * @param userList1 列表1 * @param userList2 列表2 * @return 两个列表交集 */ private static List&lt;User&gt; toSetAndFilter(List&lt;User&gt; userList1, List&lt;User&gt; userList2) &#123; Set&lt;String&gt; uidSet = userList1.stream() .map(User::getUid) .collect(Collectors.toSet()); return userList2.stream() .filter(user -&gt; uidSet.contains(user.getUid())) .collect(Collectors.toList()); &#125;&#125;","categories":[{"name":"Java 8","slug":"Java-8","permalink":"http://yoursite.com/categories/Java-8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Streams","slug":"Streams","permalink":"http://yoursite.com/tags/Streams/"}]},{"title":"Java 中静态代码块及对象的初始化顺序","slug":"Java-Initialization","date":"2018-05-13T07:38:34.000Z","updated":"2018-06-03T06:26:52.870Z","comments":true,"path":"2018/05/13/Java-Initialization/","link":"","permalink":"http://yoursite.com/2018/05/13/Java-Initialization/","excerpt":"第一篇文章，文章内容是 17年1月3日写于CSDN，当时还在学 Java 基础内容。","text":"第一篇文章，文章内容是 17年1月3日写于CSDN，当时还在学 Java 基础内容。 创建3个类1、MyPrint类，用于打印变量12345public class MyPrint &#123; public MyPrint(String word) &#123; System.out.println(word); &#125;&#125; 2、Parent类1234567891011121314151617public class Parent &#123; static MyPrint MP = new MyPrint(\"Parent's static variable\");//1 MyPrint mp = new MyPrint(\"Parent's member variable\");//5 static &#123; System.out.println(\"Parent's static code block\");//2 &#125; &#123; System.out.println(\"Parent's code block\");//6 &#125; public Parent() &#123; System.out.println(\"Parent's Constructor\");//7 &#125;&#125; 3、Child类1234567891011121314151617public class Child extends Parent &#123; static &#123; System.out.println(\"Child's static code block\");//3 &#125; static MyPrint MP = new MyPrint(\"Child's static variable\");//4 &#123; System.out.println(\"Child's code block\");//8 &#125; MyPrint mp = new MyPrint(\"Child's member variable\");//9 public Child() &#123; System.out.println(\"Child's Constructor\");//10 &#125;&#125; 创建Test类12345public class Test &#123; public static void main(String[] args) &#123; new Child(); &#125;&#125; 运行Test类，得到以下输出结果：12345678910Parent's static variableParent's static code blockChild's static code blockChild's static variableParent's member variableParent's code blockParent's ConstructorChild's code blockChild's member variableChild's Constructor 结果分析Test类中主函数执行，new Child();后的执行顺序已在代码中标出。通过上述，总结子类继承父类时的初始化顺序：1、父类静态变量和静态代码块（先声明的先执行）；2、子类静态变量和静态代码块（先声明的先执行）；3、父类的成员变量和代码块（先声明的先执行）；4、父类的构造函数；5、子类的成员变量和代码块（先声明的先执行）；6、子类的构造函数。 再简练点：1、初始化父类和子类的静态变量和静态代码块；2、初始化父类的成员变量和代码块，而后调用父类的构造函数；3、初始化子类的成员变量和代码块，而后调用子类的构造函数。 总结1、所有初始化过程都在构造函数被调用之前发生；2、静态初始化只有在必要时刻才会进行，并且只在对象被第一次创建（或者第一次访问静态数据）时，它才会被初始化，此后，静态对象不会再次被初始化；3、初始化顺序一般是先静态，后非静态。","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://yoursite.com/categories/Java-基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]}